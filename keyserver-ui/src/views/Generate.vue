<!--
  - Copyright (c) 2021. Erik Escher. PortuLock Keyserver. GPL-3.0-only.
  - SPDX-License-Identifier: GPL-3.0-only
  -->

<template>
    <div>
        <h1> Key Generation </h1>
        <div v-if="stage_generate">
          <FormulateForm v-model="formValues" @submit="generate">
              <FormulateInput type="group" name="userIDs" label="User Identities" add-label="Add identity" :repeatable="true">
                  <FormulateInput type="text" name="name" label="Full Name"/>
                  <!-- <FormulateInput type="text" name="comment" label="Comment"/> -->
                  <FormulateInput type="email" name="email" label="Email address"/>
              </FormulateInput>
              <FormulateInput type="password" name="passphrase" label="Passphrase to protect the key"/>
              <FormulateInput type="password" name="passphrase_confirm" label="Confirm passphrase" validation="confirm"/>
              <FormulateInput type="submit" name="Generate"/>
          </FormulateForm>
        </div>
        <div v-if="stage_download || stage_submitted">
          <display-key-components :rawkey="armoredKey.publicKey" disable_download_button="True"/>
          <zip-file-download-button :files="zip_files" :label="'Download Certificate Bundle (do not share)'" :file-name="'certificate-bundle-' + generatedKey.publicKey.getFingerprint() + '.asc'"/>
        </div>
        <div v-if="stage_download">
            <FormulateForm @submit="submit">
                <FormulateInput type="checkbox" name="confirmation" label="I have downloaded and stored the bundle." validation="accepted"/>
                <FormulateInput type="submit" name="Submit to Keyserver"/>
            </FormulateForm>
        </div>
      <div v-if="stage_submitted">
        <p>Download your certificate bundle if you haven't already. This is your last chance to do that.</p>

        <p>
          Make a note of your fingerprint as displayed above.
          Others might ask you for it to check that this key was actually generated by you.
        </p>

        <p>
          You will now receive a set of emails asking you to prove access to any emails on your key
          and log in using single-sign-on-accounts that confirm the names used above.
          When verifying your identity using the provided links make sure to compare your fingerprint when asked to do so.
        </p>

        <p>
          You can follow the status of your keys certification on the
          <a :href="management_link_auth">Management Page</a>
          for this key.

          Once that page shows all userids and key components as published,
          you should import your private key and the signed CAs from the certificate bundle into your client and tell it to fetch updates to your key.
        </p>
      </div>
    </div>
</template>

<script>
import {generateKey, decryptKey} from "openpgp";
import DisplayKeyComponents from '../components/DisplayKeyComponents.vue';
import TextFileDownloadButton from '../components/TextFileDownloadButton.vue';
import { mapState } from 'vuex'
import HKP from '@openpgp/hkp-client';
import ManagementTokenGenerator from "@/services/ManagementTokenGenerator";
import TrustSigner from "@/services/TrustSigner";
import ZipFileDownloadButton from "@/components/ZipFileDownloadButton";

export default {
    components: {ZipFileDownloadButton, DisplayKeyComponents, TextFileDownloadButton },
    data() {
        return {
            formValues: {},
            generatedKey: undefined,
            armoredKey: undefined,
            revocationCertificate: undefined,
            stage: "generate",
            management_link_auth: undefined,
            signed_cas: ""
        };
    },
    computed: {
        management_link() {
            let management_link = "/manage/status?fpr=" + this.fpr
            console.log("updated management link: ", management_link)
            return management_link
        },
        stage_generate() {
           return this.stage === "generate"
        },
        stage_download() {
          return this.stage === "download"
        },
        stage_submitted() {
          return this.stage === "submitted"
        },
        ...mapState([
            'config'
        ]),
        zip_files() {
          let files =  [
            {
              name: "Public Key.asc",
              content: this.armoredKey.publicKey
            },
            {
              name: "Private Key.asc",
              content: this.armoredKey.privateKey
            }
          ]
          if (this.revocationCertificate) {
            files.push({
              name: "Revocation Certificate.asc",
              content: this.revocationCertificate
            })
          }
          if (this.signed_cas.length > 0) {
            files.push({
              name: "Signed CA Certificates.asc",
              content: this.signed_cas
            })
          }
          return files
        }
    },
    methods: {
        async generate(formValues) {
            await this.generate_key()
            await this.create_management_link()
            await this.trust_sign_cas()
            this.stage = "download"
        },
        async submit() {
          await this.upload_certificate()
          this.stage = "submitted"
          await this.upload_revocation()
        },
        async generate_key() {
          let formValues = this.formValues
          delete formValues.passphrase_confirm

          let key = await generateKey({
            ...this.config.key_generation,
            ...formValues,
            format: "object"
          })
          let decryptedPrivateKey = await decryptKey({
            privateKey: key.privateKey,
            passphrase: formValues.passphrase
          })

          this.generatedKey = {
            publicKey: key.publicKey,
            revocationCertificate: key.revocationCertificate,
            privateKey: decryptedPrivateKey
          }
          this.fpr = key.publicKey.getFingerprint()
          this.armoredKey = {
            publicKey: key.publicKey.armor(),
            privateKey: key.privateKey.armor(),
          }
          this.revocationCertificate = key.revocationCertificate
        },
        async create_management_link() {
          let management_token = await new ManagementTokenGenerator(this.$http).obtainToken(this.generatedKey.privateKey)
          this.management_link_auth = "/manage/status?management_token=" + management_token
        },
        async upload_certificate() {
          const hkp = new HKP(window.location.origin)
          await hkp.upload(this.armoredKey.publicKey)
          console.log("Key submitted successfully")
        },
        async upload_revocation() {
          if (this.config.store_revocation){
            await this.$http.post("/manage/store_revocations", this.revocationCertificate, {
              params: {
                fpr: this.fpr
              },
              headers: {
                "Content-Type": "text/plain"
              },
              timeout: 5000,
              withCredentials: false,
            }).then(response => {
              console.log("STORE_REVOCATION - response: ", response)
            })
          }
        },
        async trust_sign_cas() {
          const trust_signer = new TrustSigner(this.generatedKey.privateKey)
          const hkp = new HKP(window.location.origin)

          for (const trust_sign_config of this.config.trust_sign) {
            console.log("Trust Signing:", trust_sign_config)
            try {
              let signed_ca = await trust_signer.sign(trust_sign_config.ca, trust_sign_config.domain_scope)

              let described_armored_cert  = (trust_sign_config.name ? trust_sign_config.name + "\n" : "") +
                  "Fingerprint: " + signed_ca.getFingerprint() +
                  (signed_ca.getUserIDs().length > 0 ? "\nUserID: " + signed_ca.getUserIDs()[0] : "") +
                  "\n\n" + signed_ca.armor() + "\n\n"
              console.log("Signed CA key:", described_armored_cert)
              this.signed_cas = this.signed_cas + described_armored_cert

              /* Trust Signatures could be used to flood the CA Certificate so they are currently not accepted.
              if (trust_sign_config.upload) {
                await hkp.upload(signed_ca.armor())
              }
               */
            } catch (e) {
              console.log("ERROR during trust_sign (WASM): ", e)
            }
          }
        },
    }
}
</script>
